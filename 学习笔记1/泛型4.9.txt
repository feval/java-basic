/*
泛型类：
1. 类名<类型参数>
2. 泛型类的属性类型私用类型参数
3. 泛型类实例化的对象时，
   + 类型参数的具体类型必须是引用数据类型，如果想使用基本数据类型换成包装类型
   + 变量类型中指定类型参数的具体类型，
   + 构造方法中可以省略类型参数的具体类型，<>不能省
   + 使用了类型参数的属性的类型即是类型参数的具体类型
4. 泛型类的类型参数可以定义多个，之间用英文逗号分隔，注意字母不能重复

泛型方法：
1. 泛型方法是独立定义（可以单独定义泛型方法），和类没有直接关系
2. 泛型方法的类型参数是在方法返回值类型的前面定义 <T,...>
3. 泛型方法的类型参数：方法之间没关系，和类也没关系


通配符：
1. ? 表示通配符，可以接收任意的类型参数的类型，但是对象不能再次修改
2. ? extends classType :  泛型的上限 ?类型是classType或者子类
   上限 eg: T extends classType
   应用在类，方法
   应用到方法中内容仍然不能修改
3. ? super  classType  :  泛型的下限 ?类型是classType或者父类
   下限 eg: ? super classType
   应用到方法
   应用到方法中内容可以修改的，但是主要修改的数据类型classType或者子类类型

泛型接口
1. 在定义接口时，声明类型参数
2. 实现
第一种： 实现类保留类型参数
         implementClassType<T> implements interfaceClassType<T>
         使用的时候和泛型类使用方式一致，使用时需要指定类型参数的具体类型
第二种： 实现类不保留类型参数，实现的时候确定了具体类型
         implementClassType implements interfaceClassType<具体类型>
         使用的时候和普通类使用方式一致

类型擦除：
1. 编译时进行类型擦除，在运行时泛型和普通类型一样的
2. 如果泛型类型参数未指定上限，类型擦除之后泛型类型属性的类型变成：Object类型
2. 如果泛型类型参数指定上限，类型擦除之后泛型类型属性的类型变成：上限的类型
 */